# 复杂度分析

## 复杂度分析指标

时间复杂度：执行效率（渐进时间复杂度）
空间复杂度：资源消耗

## 为什么需要复杂度分析

### 复杂度分析法

我们需要不依赖数据的方法统计

### 事后统计法

测试结果非常依赖测试环境
测试结果受数据规模的影响很大

## 时间复杂度分析

1.只关注循环执行次数最多的一段代码
2.加法法则：总复杂度等于量级最大的那段代码的复杂度
3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

## 复杂度量级

### 多项式量级

* O(1)
一般不存在循环、递归

* O(logn)和O(nlogn)

```javascript
while(i < n) {
    i *= 2;
}
```

* O(m + n)、O(m*n)

O(T(m) + T(n)) = O(m + n)

O(T(m) \* T(n)) = O(m * n)

### 非多项式量级

O(2^n)和 O(n!)

## 空间复杂度分析

常见的有O(1)、O(n)、O(n^2)

## 最好时间复杂度

## 最坏时间复杂度

## 平均时间复杂度

期望时间复杂度

## 均摊时间复杂度

摊还分析法
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放到一块儿分析，看能否将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。

## 思考

```c
int array[] = new int[10];
int len = 10;
int i = 0;

void add(int element) {
    if (i >= len) {
        int new_array[] = new int[len * 2];
        for (int j = 0; j < len; j++) {
            new_array[j] = array[j];
        }
        array = new_array;
        len = 2 * len;
    }
    array[i] = element;
    i++;
}

```

* 渐进时间复杂度 O(n)

* 最好时间复杂度 O(1)

* 最坏时间复杂度 O(n)

* 平均时间复杂度1 O(1)

* 期望时间复杂度 O(1)

* 均摊时间复杂度 O(1)
