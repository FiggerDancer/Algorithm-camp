# 链表

## 缓存

缓存大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略

1. 先进先出策略FIFO
2. 最少使用策略LFU
3. 最近最少使用策略LRU

零散的内存块，不需要连续的内存空间，需要使用指针

链表随机访问的性能需要O(n)复杂度

插入O(1)

删除O(1)

## 链表种类

1.单链表
2.循环链表
3.双向链表：最常用，用空间换时间
4.双向循环链表

## 缺点

链表的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。

## LRU缓存淘汰算法

维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果次数据没有在缓存链表中，又可以分两种情况：

* 若此时缓存未满，则将此结点直接插入到链表的头部

* 若此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

我们还可以通过 **散列表** 进行优化

## 判断一个字符串是否是回文字符串

1.利用快慢指针定位中间结点
2.从中间结点对后半部分逆序
3.前后半部分比较，判断是否为回文
4.后半部分逆序复原

时间复杂度O(n)
空间复杂度O(1)

## 技巧

1. 理解指针或引用的含义
2. 警惕指针丢失和内存泄漏
3. 利用哨兵简化实现难度
4. 重点留意边界条件处理
5. 举例画图，辅助思考
6. 多写多练，没有捷径

## 常见链表操作

1. 单链表反转
2. 链表中环的检测
3. 两个有序的链表合并
4. 删除链表倒数第n个结点
5. 求链表的中间结点

## 前端链表题目

* 链表的处理：合并、删除等（删除操作画个记号，重点中的重点！）
* 链表的反转及其衍生题目
* 链表成环问题及其衍生题目
