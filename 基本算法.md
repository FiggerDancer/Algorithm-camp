# 基本算法

## 贪心算法

### 应用

霍夫曼编码、Prim和Kruskal最小生成树算法、Dijkstra单源最短路径算法

任务调度、教师排课

### 理解

第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。

第二步，我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。

第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。

贪心算法不工作的主要原因是，前面的选择，会影响后面的选择.

### 霍夫曼编码

如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。

为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。

任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串

我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，

现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。

## 分治算法

### 分治算法-应用

MapReduce

### 分治算法-理解

分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。

这个定义看起来有点类似递归的定义。关于分治和递归的区别，我们在排序（下）的时候讲过，分治算法是一种处理问题的思想，递归是一种编程技巧。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：

+ 分解：将原问题分解成一系列子问题；
+ 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
+ 合并：将子问题的结果合并成原问题。

分治算法能解决的问题，一般需要满足下面这几个条件：

+ 原问题与分解成的小问题具有相同的模式；
+ 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；
+ 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
+ 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。

### 分治算法问题

#### 二维平面上有 n 个点，如何快速计算出两个距离最近的点对？

#### 有两个 n\*n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A\*B？

### MapReduce

MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。

## 回溯算法

笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。

回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。、

## 回朔算法问题

### n皇后问题

```javascript
const result = [];

function isOk(n, row, column) {
    let leftup = column - 1, rightup = column + 1;
    for (let i = row - 1; i >= 0; i--) { // 逐行往上考察每一行
        if (result[i] === column) return false; // 第行column有棋子吗
        if (leftup >= 0) { // 考察左上对角线，第i行leftup列有棋子吗？
            if (result[i] === leftup) return false;
        }
        if (rightup < n) { // 考察右上对角线；第i行rigtup列有棋子吗？
            if (result[i] === rightup) return false;
        }
        leftup--;
        rightup++;
    }
    return true;
}

function printQueens(result) {
    const str = [];
    for (let row = 0; row < 8; row++) {
        for (let column = 0; column < 8; column++) {
            if (result[row] === column) {
                str.push('Q ');
            } else {
                str.push('* ');
            }
        }
        str.push('\n');
    }
    console.log(str.join(''));
}

function calcNQueens(n, row = 0) {
    if (!n) return;
    if (row === n) { // n个棋子都放好了，打印结果
        return printQueens(result);
    }
    for (let column = 0; column < n; ++column) { // 每一行有n种放法
        if (isOk(n, row, column)) {
            result[row] = column; // 第row行的棋子放到column列
            calcNQueens(n, row + 1); // 考察下一行
        }
    }
}
```

### 0-1背包问题

```javascript
let maxW = 0; // 存储背包中物品总重量的最大值
// cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；
// w背包重量；items表示每个物品的重量；n表示物品个数
// 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：
// f(0, 0, a, 100)
function f(i, cw, items, w) {
    const n = items.length;
    if (cw === w || i === n) { // cw === w 表示装满了；i===n表示已经考察完所有的物品
        if (cw > maxW) {
            maxW = cw;
        }
        return;
    }
    f(i + 1, cw, items, w); // 下一个不装
    if (cw + items[i] <= w) { // 已经超过可以背包承受的重量时，就不要装了
        f(i + 1, cw + items[i], items, w); // 下一个装
    } 
}
```

### 正则表达式

```javascript
class Pattern {
  constructor(pattern) {
    this.matched = false;
    this.pattern = pattern;
    this.plen = this.pattern.length;
  }
  match(text) {
    this.matched = false;
    this.rmatch(0, 0, text, text.length)
  }
  rmatch(ti, pj, text, tlen) {
    if (this.matched) return; // 如果已经匹配了，就不要继续递归了
    if (pj === this.plen) { // 正则表达式到结尾了
      if (ti === tlen) {
        this.matched = true; // 文本串也到结尾了
        return;
      }
      if (this.pattern[pj] === '*') { // 匹配任意个字符
        for (let k = 0; k < tlen - ti; k++) {
          rmatch(ti + k, pj + 1, text, tlen);
        }
      } else if (this.pattern[pj] === '?') { // * 匹配0个或者1个字符
        rmatch(ti, pj + 1, text, tlen);
        rmatch(ti + 1, pj + 1, text, tlen);
      } else if (ti < tlen && this.pattern[pj] === text[ti]) { // 纯字符匹配才行
        rmatch(ti + 1, pj + 1, text, tlen);
      }
    }
  }
}
```

## 回朔算法小结

回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。

尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如我们开头提到的深度优先搜索、八皇后、0-1 背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。

## 动态规划

Dynamic Programming

动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。

### 0-1背包问题（动态规划）

递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。

从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。我们可以借助递归那一节讲的“备忘录”的解决方式，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。

对之前回溯算法的改造：

```javascript
let maxW = 0; // 结果放到maxW中
const weight = [2 ,2, 4, 6, 3]; // 物体重量
const w = 9; // 背包最大承受重量
const mem = new Array(n).fill(weight.length).map((a) => new Array(w + 1).fill(false));
function f(i, cw) {
  if (cw === w || i === n) {
    if (cw > maxW) {
      maxW = cw;
    }
    return;
  }
  if (mem[i][cw]) return;
  mem[i][cw] = true;
  f(i + 1, cw);
  if (cw + weight[i] <= w) {
    f(i + 1, cw + weight[i]); // 选择装第i个物品
  }
}
```

动态规划：

我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。

我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是，我们就成功避免了每层状态个数的指数级增长。

我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。

第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。

第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。

以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。

```javascript
function knapsack(weight, w) {
  const states = new Array(weight.length).fill(0).map(() => new Array(w + 1).fill(false));
  states[0][0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化
  if (weight[0] <= w) {
    states[0][weight[0]] = true;
  }
  for (let i = 1; i < weight.length; i++) { // 动态规划状态转移
    for (let j = 0; j <= w; j++) { // 不把第i个物品放入背包
      if (states[i - 1][j]) {
        states[i][j] = states[i - 1][j];
      }
    }
    for (let j = 0; j <= w - weight[i]; j++) { // 把第i个物品放入背包
      if (states[i - 1][j]) {
        states[i][j + weight[i]] = true;
      }
    }
  }
  for (let i = w; i >= 0; i--) { // 输出结果
    if (states[weight.length - 1][i]) {
      return i;
    }
  }
  return 0;
}
```

优化空间复杂度：

```javascript
function knapsack(weight, w) {
  const states = new Array(w + 1).fill(false);
  states[0] = true; // 第一行的数据要特殊处理，可以利用哨兵优化
  if (weight[0] <= w) {
    states[weight[0]] = true;
  }
  for (let i = 1; i < weight.length; i++) { // 动态规划状态转移
    for (let j = w - weight[i]; j >= 0; j--) { // 从大的开始循环，把第i个物品放入背包，如果从小的开始循环，会有重复
      if (states[j]) {
        states[j + weight[i]] = true;
      }
    }
  }
  for (let i = w; i >= 0; i--) { // 输出结果
    if (states[i]) {
      return i;
    }
  }
  return 0;
}
```

### 0-1背包问题升级版

我们刚刚讲的背包问题，只涉及背包重量和物品重量。我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？

回朔法：

```javascript
let maxV = 0;
const weight = [2 ,2, 4, 6, 3]; // 物体重量
const value = [3 ,4, 8, 9, 6]; // 物体价值
const w = 9; // 背包最大承受重量
function f(i, cw, cv) {
  if (cw === w || i === n) {
    if (cv > maxV) maxV = cv;
    return;
  }
  f(i + 1, cw, cv);
  if (cw + weight[i] <= w) {
    f(i + 1, cw + weight[i], cv + value[i]);
  }
}
```

动态规划：

```javascript
function knapsack3(weight, value, w) {
  const states = new Array(weight.length).fill(0).map((a) => new Array(w + 1).fill(-1));
  states[0][0] = 0;
  if (weight[0] <= w) {
    states[0][weight[0]] = value[0];
  }
  for (let i = 1; i < weight.length; i++) {
    for (let j = 0; j <= w; j++) { // 不选择第i个物体
      if (states[i - 1][j] >= 0) {
        states[i][j] = states[i - 1][j];
      }
    }
    for (let j = 0; j <= w - weight[i]; j++) { // 选择第i个物体
      if (states[i - 1][j] >= 0) {
        const v = states[i - 1][j] + value[i];
        if (v > states[i][j + weight[i]]) {
          states[i][j + weight[i]] = v;
        }
      }
    }
  }
  let maxValue = -1;
  for (let j = 0; j <= w; j++) {
    if (states[weight.length - 1][j] > maxValue) {
      maxValue = states[weight.length - 1][j];
    }
  }
  return maxValue;
}
```

最小总价格购买哪些商品:

要求大于等于200，但不能大于600

```javascript
function double11advance(items, w) {
  const states = new Array(items.length).fill(0).map(() => new Array(3 * w + 1).fill(false));
  states[0][0] = true;
  if (items[0] <= 3 * w) {
    states[0][items[0]] = true;
  }
  for (let i = 1; i < items.length; i++) {
    for (let j = 0; j <= 3 * w; j++) {
      if (states[i - 1][j]) {
        states[i][j] = states[i - 1][j];
      }
    }
    for (let j = 0; j <= 3 * w - items[i]; j++) {
      if (states[i - 1][j]) {
        states[i][j + items[i]] = true;
      }
    }
  }
  let j;
  for (j = w; j < 3 * w + 1; j++) {
    if (states[weight.length - 1][j]) break;
  }
  if (j === 3 * w + 1) return; // 没有可行解
  const result = [];
  for (let i = weight.length - 1; i >= 1; i--) {
    if (j - items[i] >= 0 && states[i - 1][j - items[i]]) {
      result.push(items[i]);
      j = j - items[i];
    }
  }
  console.log(result.join(' '));
  if (j !== 0) {
    console.log(items[0]);
  }
}
```

### 一个模型三个特征

一个模型：

多阶段决策最优解模型

三个特征：

最优子结构、无后效性、重复子问题

#### 最优子结构

那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

#### 无后效性

无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

#### 重复子问题

不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

### 动态规划解题思路

解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法。

#### 状态转移表法

从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。

第一种是直接用回溯加“备忘录”的方法，来避免重复子问题。

我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。

尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。

总结：

**回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。**

#### 状态转移方程法

状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是递归加“备忘录”，另一种是迭代递推。

状态转移方程是解决动态规划的关键。

不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。

总结

**找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。**

### 量化字符串相似度

编辑距离指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。

莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。

## 四种算法思想比较分析

前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。

回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。

尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。

贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。

其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。
